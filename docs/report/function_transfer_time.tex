\section{Decreasing function transfer time}\label{sec:function-transfer-time}

Each time \code{seq} is invoked on a chain, all callback functions related to \code{map}, \code{filter} and \code{reduce} steps are serialized and sent to the Web Workers.

Each Web Worker has a cache to avoid using different instances of the same function (as explained in Section~\ref{sec:func-caching}). Nevertheless, if the same function is going to be used multiple times in a program as the callback for steps, it might make sense to send them to the Web Workers once and then simply make use of them.

This can be achived by taking advantage of the global context object (detailed in Section~\ref{sec:context}).

The first thing that needs to be done is to call \code{pjs.updateContext} by providing a \tfunction{} as a property of the context parameter. An example is shown in the following code snippet:
\begin{lstlisting}[caption=Sending function in global context]
var promise = pjs.updateContext({
  add: function (x) { return x + 2; },
});
\end{lstlisting}

Once the global context has been updated, the \tstring{} representation of the function's key (\code{'add'}) can be used as a callback parameter instead of using a \tfunction{} instance. An example is shown in the following code snippet:
\begin{lstlisting}[caption=Passing a function name from the global context instead of a funciton as a callback]
var promise = pjs.updateContext({
  add: function (x) { return x + 2; },
}).then(function(){
  pjs(new Uint8Array([1,2,3,4])).map('add').seq()
    .then(function(result){
      // result is [ 3, 4, 5, 6 ]
    });
});
\end{lstlisting}

\subsection{Benchmark}
We created a benchmark to analyze the improvement obtained by just sending a \tstring{} instead of a \tfunction{} instance.

\note{The improvement will vary if the difference in character length between the key and the function's code does.}