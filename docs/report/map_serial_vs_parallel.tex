\section{\code{map}: Sequential vs parallel}

Since as explained in Section~\ref{sec:serialization-and-transference} the cost of transferring objects is not zero, it is important to compare the performance of our parallel implementation against a serial one.

In this regard, the more complex the computation to be performed on each array element the better the parallel implementation will perform. That is because in the parallel case, the source \ttarray{} must be copied to sub-arrays in order to be transferred. On the contrary, the serial implementation operates on elements during that time.

\subsection{Algorithm selection}
For this benchmark we decided to use an algorithm that applies a sepia tone effect to pictures. This meets the criteria of both being useful and having some calls to \code{Math.random} which make it more computationally complex.

\subsection{Benchmark code}
The benchmark code is introduced in the following code listing:
\bmcode{http://jsperf.com/pjs-map-vs-serial/8}{../../spikes/3.1.3/comparison/jspBenchmark.js}

\note{Unlike other benchmarks in which we were comparing different ways to achieve the same result, this benchmark compares a single way with a changing amount of elements. For that reason, the original charts are not displayed.}

The results for the benchmark are displayed in Figure~\ref{fig:map-par-vs-seq}.
\img{Relative performance of parallel implementation with regards to sequential one}{../../spikes/3.1.3/comparison/chart}{fig:map-par-vs-seq}

\subsection{Conclusion}
The parallel improvement might be more noticeable in lower end machines since the linear implementation would be able to operate on less elements ``while the parallel is doing the split'', since the first is a computationally expensive operationa and the other one isn't. This is consistent with our findings based on the machine specifications in \ref{sub-sec:serialization-and-transference}.

\pagebreak