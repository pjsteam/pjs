\section{\code{map}: Sequential vs parallel}

Since as explained in \ref{sec:serialization-and-transference} the cost of transferring objects is not zero, it is important to compare the performance of our parallel implementation against a serial one.

In this regard, the more complex the computation to be performed on each array element the better the parallel implementation will perform. That is because in the parallel case, the source \ttarray{} must be copied to sub-arrays in order to be transferred. On the contratry, the serial implementation can take that time to actually operate on some elements.

\subsection{Algorithm selection}
For this benchmark we decided to use an algorithm that applies a sepia tone effect to pictures. This meets the criteria of both being useful and having some calls to \code{Math.random} which make it more computationally complex.

\subsection{Benchmark code}
The benchmark code is introduced in the following code listing:
\bmcode{http://jsperf.com/pjs-map-vs-serial/3}{../../spikes/3.1.3/comparison/jspBenchmark.js}

\note{Unlike other benchmarks in which we were comparing different ways to achieve the same, this benchmark compares the same thing with different element amounts. That's why the original charts are not displayed.}

The results for the benchmark are displayed in Figure~\ref{fig:map-par-vs-seq}.
\img{Relative performance of parallel implementation with regards to sequential one}{../../spikes/3.1.3/comparison/chart}{fig:map-par-vs-seq}

\subsection{Conclusion}
The parallel improvement might be more noticeable in lower end machines since the linear implementation would be able to operate on less elements ``while the parallel is doing the split'', since the first is a computationally expensive operationa and the other one isn't. This is consistent with our findings based on the machine specifications in \ref{sub-sec:serialization-and-transference}.

\pagebreak